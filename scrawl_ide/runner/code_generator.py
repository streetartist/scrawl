"""
Code Generator

Generates runnable Python code from the project model by merging
all sprite and scene class definitions into a single file.
"""

import os
import re
from typing import Optional, List, Set

from models import ProjectModel, SceneModel, SpriteModel


class CodeGenerator:
    """Generates Python code from project models."""

    def __init__(self, project: ProjectModel, project_dir: str):
        self.project = project
        self.project_dir = project_dir

    def generate_main(self) -> str:
        """Generate the complete game script by merging all code."""
        game = self.project.game
        scenes = self.project.scenes

        code_parts = []

        # 1. File header with encoding declaration
        code_parts.append('# -*- coding: utf-8 -*-')
        code_parts.append('"""')
        code_parts.append(f'Generated by Scrawl IDE - {self.project.name}')
        code_parts.append('"""')
        code_parts.append('')

        # 2. Imports
        code_parts.append('import pygame')
        code_parts.append('from scrawl import (')
        code_parts.append('    Game, Scene, Sprite, PhysicsSprite,')
        code_parts.append('    on_key, on_mouse, as_main, as_clones,')
        code_parts.append('    on_sprite_collision, on_edge_collision, on_broadcast, on_sprite_clicked')
        code_parts.append(')')
        code_parts.append('')
        code_parts.append(f'# 项目目录')
        code_parts.append(f'PROJECT_DIR = r"{self.project_dir}"')
        code_parts.append('')

        # 3. Game constants
        code_parts.append('# 游戏配置')
        code_parts.append(f'SCREEN_WIDTH = {game.width}')
        code_parts.append(f'SCREEN_HEIGHT = {game.height}')
        code_parts.append(f'GAME_TITLE = "{game.title}"')
        code_parts.append(f'GAME_FPS = {game.fps}')
        code_parts.append(f'FULLSCREEN = {game.fullscreen}')
        code_parts.append('')

        # 4. Sprite classes - from each sprite's inline code
        code_parts.append('# ' + '=' * 60)
        code_parts.append('# 精灵类定义')
        code_parts.append('# ' + '=' * 60)
        code_parts.append('')

        generated_classes: Set[str] = set()

        for scene in scenes:
            for sprite in scene.sprites:
                if sprite.class_name not in generated_classes:
                    sprite_code = self._get_sprite_code(sprite)
                    if sprite_code.strip():
                        code_parts.append(sprite_code)
                        code_parts.append('')
                    generated_classes.add(sprite.class_name)

        # 5. Scene classes - from each scene's inline code
        code_parts.append('# ' + '=' * 60)
        code_parts.append('# 场景类定义')
        code_parts.append('# ' + '=' * 60)
        code_parts.append('')

        for scene in scenes:
            scene_code = self._get_scene_code(scene)
            code_parts.append(scene_code)
            code_parts.append('')

        # 6. Main execution
        code_parts.append('# ' + '=' * 60)
        code_parts.append('# 游戏入口')
        code_parts.append('# ' + '=' * 60)
        code_parts.append('')
        code_parts.append('if __name__ == "__main__":')
        code_parts.append(f'    game = Game(width=SCREEN_WIDTH, height=SCREEN_HEIGHT, title=GAME_TITLE, fullscreen=FULLSCREEN)')

        # Load sounds
        if self.project.sounds:
            code_parts.append('')
            code_parts.append('    # 加载音效')
            for sound_path in self.project.sounds:
                sound_name = os.path.splitext(os.path.basename(sound_path))[0]
                rel_path = sound_path.replace('\\', '/')
                code_parts.append(f'    game.load_sound("{sound_name}", r"{rel_path}")')

        if scenes:
            # Use first scene as the starting scene
            first_scene = scenes[0]
            scene_class_name = self._get_scene_class_name(first_scene)
            code_parts.append(f'    game.set_scene({scene_class_name}())')

        # Debug mode
        debug_mode = self.project.game.debug
        code_parts.append(f'    game.run(fps=GAME_FPS, debug={debug_mode})')
        code_parts.append('')

        return '\n'.join(code_parts)

    def _get_sprite_code(self, sprite: SpriteModel) -> str:
        """Get the sprite class code, with costume setup injected."""
        code = sprite.code.strip()
        target_base = "PhysicsSprite" if sprite.is_physics else "Sprite"

        if not code:
            # Generate default code if none exists
            code = f'''class {sprite.class_name}({target_base}):
    def __init__(self):
        super().__init__()
        self.name = "{sprite.name}"
'''
        else:
            # Replace base class if it doesn't match is_physics setting
            code = self._replace_base_class(code, sprite.class_name, target_base)

        # Inject costume loading and physics setup into __init__ if needed
        inject_parts = []

        if sprite.costumes:
            inject_parts.append(self._generate_costume_code(sprite))

        # Inject collision type if not default
        if sprite.collision_type != "rect":
            inject_parts.append(f'        self.set_collision_type("{sprite.collision_type}")')

        # Inject physics properties if physics sprite
        if sprite.is_physics:
            inject_parts.append(f'        self.set_gravity({sprite.gravity_x}, {sprite.gravity_y})')
            inject_parts.append(f'        self.set_friction({sprite.friction})')
            inject_parts.append(f'        self.set_elasticity({sprite.elasticity})')

        if inject_parts:
            inject_code = '\n'.join(inject_parts)
            code = self._inject_into_init(code, inject_code)

        return code

    def _replace_base_class(self, code: str, class_name: str, target_base: str) -> str:
        """Replace the base class in a class declaration to match is_physics setting."""
        # Match: class ClassName(Sprite): or class ClassName(PhysicsSprite):
        pattern = rf'(class\s+{re.escape(class_name)}\s*\(\s*)(Sprite|PhysicsSprite)(\s*\)\s*:)'
        replacement = rf'\g<1>{target_base}\g<3>'
        return re.sub(pattern, replacement, code)

    def _generate_costume_code(self, sprite: SpriteModel) -> str:
        """Generate costume loading code."""
        lines = []
        for costume in sprite.costumes:
            # Use costume name and path from CostumeData
            costume_name = costume.name
            costume_path = costume.path
            # Make path relative or use absolute
            if os.path.isabs(costume_path):
                rel_path = os.path.relpath(costume_path, self.project_dir)
            else:
                rel_path = costume_path
            rel_path = rel_path.replace('\\', '/')
            lines.append(f'        self.add_costume("{costume_name}", pygame.image.load(r"{rel_path}").convert_alpha())')

        # Set default costume if specified
        if sprite.costumes and sprite.default_costume >= 0:
            default_costume_name = sprite.costumes[sprite.default_costume].name
            lines.append(f'        self.switch_costume("{default_costume_name}")')

        return '\n'.join(lines)

    def _inject_into_init(self, code: str, inject_code: str) -> str:
        """Inject code into the __init__ method."""
        # Find the __init__ method and add code after super().__init__()
        lines = code.split('\n')
        result = []
        in_init = False
        init_indent = 0
        injected = False

        for i, line in enumerate(lines):
            result.append(line)

            # Detect __init__ method
            if 'def __init__' in line:
                in_init = True
                init_indent = len(line) - len(line.lstrip())
                continue

            # Inject after super().__init__()
            if in_init and not injected and 'super().__init__()' in line:
                result.append('')
                result.append('        # IDE自动生成的初始化代码')
                result.append(inject_code)
                injected = True
                continue

            # Detect end of __init__
            if in_init and line.strip() and not line.strip().startswith('#'):
                current_indent = len(line) - len(line.lstrip())
                if current_indent <= init_indent and 'def ' in line:
                    in_init = False

        return '\n'.join(result)

    def _get_scene_code(self, scene: SceneModel) -> str:
        """Get the scene class code with sprite instantiation injected."""
        code = scene.code.strip()
        scene_class_name = self._get_scene_class_name(scene)

        if not code:
            # Generate default scene code
            bg = scene.background_color
            code = f'''class {scene_class_name}(Scene):
    def __init__(self):
        super().__init__()
        self.name = "{scene.name}"
        self.background_color = ({bg[0]}, {bg[1]}, {bg[2]})
'''

        # Build inject code
        inject_parts = []

        # Background image
        if scene.background_image:
            rel_path = scene.background_image.replace('\\', '/')
            inject_parts.append(f'        self.set_background_image(r"{rel_path}")')

        # Sprite creation
        if scene.sprites:
            inject_parts.append(self._generate_sprite_creation_code(scene))

        if inject_parts:
            inject_code = '\n'.join(inject_parts)
            code = self._inject_into_init(code, inject_code)

        return code

    def _get_scene_class_name(self, scene: SceneModel) -> str:
        """Get the class name from scene code or generate one."""
        # Try to extract class name from code
        if scene.code:
            match = re.search(r'class\s+(\w+)\s*\(', scene.code)
            if match:
                return match.group(1)
        # Generate from scene name
        return scene.name.replace(' ', '') + 'Scene'

    def _generate_sprite_creation_code(self, scene: SceneModel) -> str:
        """Generate code to instantiate and add sprites to scene."""
        lines = []
        lines.append('')
        lines.append('        # 精灵实例化（由IDE自动生成）')

        for sprite in scene.sprites:
            var_name = self._to_variable_name(sprite.name)
            lines.append(f'        {var_name} = {sprite.class_name}()')
            lines.append(f'        {var_name}.pos.x = {sprite.x}')
            lines.append(f'        {var_name}.pos.y = {sprite.y}')

            if sprite.direction != 90.0:
                lines.append(f'        {var_name}.direction = {sprite.direction}')
            if sprite.size != 1.0:
                lines.append(f'        {var_name}.set_size({sprite.size})')
            if not sprite.visible:
                lines.append(f'        {var_name}.visible = False')

            lines.append(f'        self.add_sprite({var_name})')
            lines.append('')

        return '\n'.join(lines)

    def _to_variable_name(self, name: str) -> str:
        """Convert a name to a valid Python variable name."""
        # Remove invalid characters and convert to lowercase
        var_name = re.sub(r'[^a-zA-Z0-9_]', '_', name)
        var_name = var_name.lower()
        # Ensure it doesn't start with a number
        if var_name and var_name[0].isdigit():
            var_name = '_' + var_name
        return var_name or 'sprite'

    def generate_sprite_template(self, sprite_name: str, is_physics: bool = False) -> str:
        """Generate a template script for a sprite."""
        class_name = sprite_name.replace(' ', '')
        base_class = "PhysicsSprite" if is_physics else "Sprite"

        physics_setup = ""
        if is_physics:
            physics_setup = '''
        # 物理属性
        self.set_gravity(0, 0.5)
        self.set_elasticity(0.8)
        self.set_friction(0.95)
'''

        return f'''class {class_name}({base_class}):
    def __init__(self):
        super().__init__()
        self.name = "{sprite_name}"{physics_setup}

    @as_main
    def main_loop(self):
        """主循环"""
        while True:
            # 在这里添加逻辑
            yield 0

    # 键盘事件示例:
    # @on_key(pygame.K_SPACE, "pressed")
    # def on_space(self):
    #     pass

    # 碰撞事件示例:
    # @on_sprite_collision("OtherSprite")
    # def on_collision(self, other):
    #     pass
'''

    def generate_scene_template(self, scene_name: str) -> str:
        """Generate a template script for a scene."""
        class_name = scene_name.replace(' ', '')

        return f'''class {class_name}(Scene):
    def __init__(self):
        super().__init__()
        self.name = "{scene_name}"
        self.background_color = (100, 150, 200)

        # 精灵会由IDE自动添加到场景
        # 你可以在这里添加额外的初始化逻辑

    @as_main
    def scene_logic(self):
        """场景主逻辑（可选）"""
        # 加载音效示例:
        # self.game.load_sound("jump", "sounds/jump.ogg")

        while True:
            yield 0
'''

    def save_generated_code(self, output_path: str) -> str:
        """Save the generated code to a file."""
        code = self.generate_main()

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(code)

        return output_path
